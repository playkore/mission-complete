import fs from "node:fs/promises";
import path from "node:path";

const DATA_DIR = path.join(process.cwd(), "src", "data");
const OUT_FILE = path.join(DATA_DIR, "scenes.ts");

function toCamelCase(input) {
  const parts = input.split(/[^a-zA-Z0-9]+/).filter(Boolean);
  if (parts.length === 0) {
    return "_scene";
  }
  const [first, ...rest] = parts;
  const name =
    first.toLowerCase() +
    rest.map((part) => part.charAt(0).toUpperCase() + part.slice(1)).join("");
  return /^[0-9]/.test(name) ? `_${name}` : name;
}

function chapterLabel(chapter) {
  const match = /^chapter(\d+)$/i.exec(chapter);
  if (match) {
    return `Chapter ${match[1].padStart(2, "0")}`;
  }
  return chapter
    .split(/[^a-zA-Z0-9]+/)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}

async function walk(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...(await walk(fullPath)));
    } else if (entry.isFile() && entry.name.endsWith(".ts")) {
      files.push(fullPath);
    }
  }
  return files;
}

async function readSceneFiles() {
  const files = await walk(DATA_DIR);
  const sceneFiles = files
    .filter((file) => path.basename(file) !== "scenes.ts")
    .filter((file) => !file.endsWith(".d.ts"))
    .sort((a, b) => a.localeCompare(b));

  const usedNames = new Map();
  const scenes = [];

  for (const file of sceneFiles) {
    const content = await fs.readFile(file, "utf8");
    const match = content.match(
      /SceneDefinition\s*=\s*{[\s\S]*?\bid\s*:\s*["']([^"']+)["']/
    );
    if (!match) {
      throw new Error(`Scene id not found in ${file}`);
    }
    const id = match[1];
    const relPath = path
      .relative(DATA_DIR, file)
      .replace(/\\/g, "/")
      .replace(/\.ts$/, "");
    const importBase = toCamelCase(path.basename(file, ".ts"));
    const count = usedNames.get(importBase) ?? 0;
    usedNames.set(importBase, count + 1);
    const importName = count === 0 ? importBase : `${importBase}${count + 1}`;

    const chapter = relPath.split("/")[0];
    scenes.push({ id, importName, relPath, chapter });
  }

  return scenes;
}

async function readInitialSceneId() {
  try {
    const existing = await fs.readFile(OUT_FILE, "utf8");
    const match = existing.match(
      /initialSceneId:\s*SceneId\s*=\s*["']([^"']+)["']/
    );
    return match ? match[1] : null;
  } catch {
    return null;
  }
}

function groupByChapter(scenes) {
  const groups = new Map();
  for (const scene of scenes) {
    const list = groups.get(scene.chapter) ?? [];
    list.push(scene);
    groups.set(scene.chapter, list);
  }
  return groups;
}

function buildFile(scenes, initialSceneId) {
  const groups = groupByChapter(scenes);
  const chapters = Array.from(groups.keys()).sort((a, b) =>
    a.localeCompare(b)
  );

  const lines = [];
  lines.push("// This file is auto-generated by generate-scenes.js.");
  lines.push("// Do not edit manually.");
  lines.push("");
  lines.push('import type { SceneDefinition } from "../types/scenes";');
  lines.push("");

  for (const chapter of chapters) {
    lines.push(`// ${chapterLabel(chapter)}`);
    for (const scene of groups.get(chapter)) {
      lines.push(`import ${scene.importName} from "./${scene.relPath}";`);
    }
    lines.push("");
  }

  lines.push("export type SceneId =");
  for (const scene of scenes) {
    lines.push(`  | "${scene.id}"`);
  }
  lines.push(";");
  lines.push("");
  lines.push("export const scenes: SceneDefinition[] = [");
  for (const chapter of chapters) {
    lines.push(`  // ${chapterLabel(chapter)}`);
    for (const scene of groups.get(chapter)) {
      lines.push(`  ${scene.importName},`);
    }
  }
  lines.push("];");
  lines.push("");
  lines.push(
    `export const initialSceneId: SceneId = "${initialSceneId}";`
  );
  lines.push("");

  return lines.join("\n");
}

async function main() {
  const scenes = await readSceneFiles();
  if (scenes.length === 0) {
    throw new Error("No scene files found under src/data.");
  }

  const existingInitial = await readInitialSceneId();
  const fallbackInitial = scenes[0].id;
  const initialSceneId =
    existingInitial && scenes.some((scene) => scene.id === existingInitial)
      ? existingInitial
      : fallbackInitial;

  const output = buildFile(scenes, initialSceneId);
  await fs.writeFile(OUT_FILE, output, "utf8");
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
