import fs from "node:fs/promises";
import path from "node:path";

const DATA_DIR = path.join(process.cwd(), "src", "data");
const OUT_FILE = path.join(DATA_DIR, "scenes.ts");
const WATCH_FLAG = "--watch";
const WATCH_DEBOUNCE_MS = 100;
const DEBUG_FLAG = "--debug";
const POLL_FLAG = "--poll";
const POLL_INTERVAL_MS = 500;
const ARGS = new Set(process.argv.slice(2));

const isDebug = () => ARGS.has(DEBUG_FLAG);
const isWatch = () => ARGS.has(WATCH_FLAG);
const isPoll = () => ARGS.has(POLL_FLAG);

function toCamelCase(input) {
  const parts = input.split(/[^a-zA-Z0-9]+/).filter(Boolean);
  if (parts.length === 0) {
    return "_scene";
  }
  const [first, ...rest] = parts;
  const name =
    first.toLowerCase() +
    rest.map((part) => part.charAt(0).toUpperCase() + part.slice(1)).join("");
  return /^[0-9]/.test(name) ? `_${name}` : name;
}

function chapterLabel(chapter) {
  const match = /^chapter(\d+)$/i.exec(chapter);
  if (match) {
    return `Chapter ${match[1].padStart(2, "0")}`;
  }
  return chapter
    .split(/[^a-zA-Z0-9]+/)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}

async function walk(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...(await walk(fullPath)));
    } else if (entry.isFile() && entry.name.endsWith(".ts")) {
      files.push(fullPath);
    }
  }
  return files;
}

async function listSceneFilePaths() {
  const files = await walk(DATA_DIR);
  return files
    .filter((file) => path.basename(file) !== "scenes.ts")
    .filter((file) => !file.endsWith(".d.ts"))
    .filter((file) => file.endsWith(".ts"))
    .sort((a, b) => a.localeCompare(b));
}

async function readSceneFiles() {
  const sceneFiles = await listSceneFilePaths();

  const usedNames = new Map();
  const scenes = [];

  for (const file of sceneFiles) {
    const content = await fs.readFile(file, "utf8");
    const match = content.match(
      /SceneDefinition\s*=\s*{[\s\S]*?\bid\s*:\s*["']([^"']+)["']/
    );
    if (!match) {
      throw new Error(`Scene id not found in ${file}`);
    }
    const id = match[1];
    const relPath = path
      .relative(DATA_DIR, file)
      .replace(/\\/g, "/")
      .replace(/\.ts$/, "");
    const importBase = toCamelCase(path.basename(file, ".ts"));
    const count = usedNames.get(importBase) ?? 0;
    usedNames.set(importBase, count + 1);
    const importName = count === 0 ? importBase : `${importBase}${count + 1}`;

    const chapter = relPath.split("/")[0];
    scenes.push({ id, importName, relPath, chapter });
  }

  return scenes;
}

async function readInitialSceneId() {
  try {
    const existing = await fs.readFile(OUT_FILE, "utf8");
    const match = existing.match(
      /initialSceneId:\s*SceneId\s*=\s*["']([^"']+)["']/
    );
    return match ? match[1] : null;
  } catch {
    return null;
  }
}

function groupByChapter(scenes) {
  const groups = new Map();
  for (const scene of scenes) {
    const list = groups.get(scene.chapter) ?? [];
    list.push(scene);
    groups.set(scene.chapter, list);
  }
  return groups;
}

function buildFile(scenes, initialSceneId) {
  const groups = groupByChapter(scenes);
  const chapters = Array.from(groups.keys()).sort((a, b) =>
    a.localeCompare(b)
  );

  const lines = [];
  lines.push("// This file is auto-generated by generate-scenes.js.");
  lines.push("// Do not edit manually.");
  lines.push("");
  lines.push('import type { SceneDefinition } from "../types/scenes";');
  lines.push("");

  for (const chapter of chapters) {
    lines.push(`// ${chapterLabel(chapter)}`);
    for (const scene of groups.get(chapter)) {
      lines.push(`import ${scene.importName} from "./${scene.relPath}";`);
    }
    lines.push("");
  }

  lines.push("export type SceneId =");
  for (const scene of scenes) {
    lines.push(`  | "${scene.id}"`);
  }
  lines.push(";");
  lines.push("");
  lines.push("export const scenes: SceneDefinition[] = [");
  for (const chapter of chapters) {
    lines.push(`  // ${chapterLabel(chapter)}`);
    for (const scene of groups.get(chapter)) {
      lines.push(`  ${scene.importName},`);
    }
  }
  lines.push("];");
  lines.push("");
  lines.push(
    `export const initialSceneId: SceneId = "${initialSceneId}";`
  );
  lines.push("");

  return lines.join("\n");
}

async function generate() {
  const scenes = await readSceneFiles();
  if (scenes.length === 0) {
    throw new Error("No scene files found under src/data.");
  }

  const existingInitial = await readInitialSceneId();
  const fallbackInitial = scenes[0].id;
  const initialSceneId =
    existingInitial && scenes.some((scene) => scene.id === existingInitial)
      ? existingInitial
      : fallbackInitial;

  const output = buildFile(scenes, initialSceneId);
  await fs.writeFile(OUT_FILE, output, "utf8");
}

async function listDirs(root) {
  const dirs = [root];
  const entries = await fs.readdir(root, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.isDirectory()) {
      const fullPath = path.join(root, entry.name);
      dirs.push(...(await listDirs(fullPath)));
    }
  }
  return dirs;
}

async function watchTree(onChange) {
  const watchers = new Map();
  const attach = async () => {
    const dirs = await listDirs(DATA_DIR);
    for (const dir of dirs) {
      if (watchers.has(dir)) {
        continue;
      }
      const watcher = fs.watch(dir, (eventType, filename) => {
        if (isDebug()) {
          const relDir = path.relative(process.cwd(), dir);
          console.log(`[watch] ${eventType} ${relDir}/${filename ?? ""}`);
        }
        if (!filename || !filename.endsWith(".ts")) {
          return;
        }
        if (path.basename(filename) === "scenes.ts") {
          return;
        }
        onChange();
      });
      watchers.set(dir, watcher);
    }
  };

  await attach();
  return {
    refresh: attach,
  };
}

function startPolling(onChange) {
  let lastSnapshot = new Map();

  const snapshot = async () => {
    const files = await listSceneFilePaths();
    const nextSnapshot = new Map();
    for (const file of files) {
      const stat = await fs.stat(file);
      nextSnapshot.set(file, stat.mtimeMs);
    }

    let changed = false;
    if (nextSnapshot.size !== lastSnapshot.size) {
      changed = true;
    } else {
      for (const [file, mtime] of nextSnapshot) {
        if (lastSnapshot.get(file) !== mtime) {
          changed = true;
          break;
        }
      }
    }

    lastSnapshot = nextSnapshot;
    if (changed) {
      if (isDebug()) {
        console.log("[poll] change detected");
      }
      onChange();
    }
  };

  const interval = setInterval(() => {
    snapshot().catch((error) => {
      console.error(error);
    });
  }, POLL_INTERVAL_MS);

  // Initial baseline.
  snapshot().catch((error) => {
    console.error(error);
  });

  return () => clearInterval(interval);
}

async function main() {
  const shouldWatch = isWatch();
  await generate();

  if (!shouldWatch) {
    return;
  }

  let timer = null;
  const schedule = () => {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => {
      if (isDebug()) {
        console.log("[watch] change detected, regenerating...");
      }
      generate().catch((error) => {
        console.error(error);
      });
    }, WATCH_DEBOUNCE_MS);
  };

  const shouldPoll =
    isPoll() || process.platform === "darwin";

  if (shouldPoll) {
    startPolling(schedule);
  } else {
    let watcher = null;
    try {
      watcher = fs.watch(
        DATA_DIR,
        { recursive: true },
        (eventType, filename) => {
          if (isDebug()) {
            const relPath = filename
              ? path.join(path.relative(process.cwd(), DATA_DIR), filename)
              : path.relative(process.cwd(), DATA_DIR);
            console.log(`[watch] ${eventType} ${relPath}`);
          }
          if (!filename || !filename.endsWith(".ts")) {
            return;
          }
          if (path.basename(filename) === "scenes.ts") {
            return;
          }
          schedule();
        }
      );
    } catch {
      watcher = null;
    }

    if (!watcher) {
      let treeWatcher = null;
      treeWatcher = await watchTree(() => {
        schedule();
        if (treeWatcher && treeWatcher.refresh) {
          treeWatcher.refresh().catch(() => {});
        }
      });
    }
  }

  console.log(
    `Watching ${path.relative(process.cwd(), DATA_DIR)} for scene changes...`
  );
  process.stdin.resume();
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
