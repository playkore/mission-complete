import fs from "node:fs/promises";
import path from "node:path";

const DATA_DIR = path.join(process.cwd(), "src", "data");
const SCENES_FILE_NAME = "scenes.ts";
const WATCH_FLAG = "--watch";
const WATCH_DEBOUNCE_MS = 100;
const DEBUG_FLAG = "--debug";
const POLL_FLAG = "--poll";
const POLL_INTERVAL_MS = 500;
const ARGS = new Set(process.argv.slice(2));

const isDebug = () => ARGS.has(DEBUG_FLAG);
const isWatch = () => ARGS.has(WATCH_FLAG);
const isPoll = () => ARGS.has(POLL_FLAG);

function toCamelCase(input) {
  const parts = input.split(/[^a-zA-Z0-9]+/).filter(Boolean);
  if (parts.length === 0) {
    return "_scene";
  }
  const [first, ...rest] = parts;
  const name =
    first.toLowerCase() +
    rest.map((part) => part.charAt(0).toUpperCase() + part.slice(1)).join("");
  return /^[0-9]/.test(name) ? `_${name}` : name;
}

function chapterLabel(chapter) {
  const match = /^chapter(\d+)$/i.exec(chapter);
  if (match) {
    return `Chapter ${match[1].padStart(2, "0")}`;
  }
  return chapter
    .split(/[^a-zA-Z0-9]+/)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
}

async function walk(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...(await walk(fullPath)));
    } else if (entry.isFile() && entry.name.endsWith(".ts")) {
      files.push(fullPath);
    }
  }
  return files;
}

async function listGameDirs() {
  const entries = await fs.readdir(DATA_DIR, { withFileTypes: true });
  return entries
    .filter((entry) => entry.isDirectory())
    .map((entry) => path.join(DATA_DIR, entry.name))
    .sort((a, b) => a.localeCompare(b));
}

async function listSceneFilePaths(gameDir) {
  const files = await walk(gameDir);
  return files
    .filter((file) => path.basename(file) !== SCENES_FILE_NAME)
    .filter((file) => !file.endsWith(".d.ts"))
    .filter((file) => file.endsWith(".ts"))
    .sort((a, b) => a.localeCompare(b));
}

async function readSceneFiles(gameDir) {
  const sceneFiles = await listSceneFilePaths(gameDir);

  const usedNames = new Map();
  const scenes = [];

  for (const file of sceneFiles) {
    const content = await fs.readFile(file, "utf8");
    const match = content.match(
      /SceneDefinition\s*=\s*{[\s\S]*?\bid\s*:\s*["']([^"']+)["']/
    );
    if (!match) {
      throw new Error(`Scene id not found in ${file}`);
    }
    const id = match[1];
    const relPath = path
      .relative(gameDir, file)
      .replace(/\\/g, "/")
      .replace(/\.ts$/, "");
    const importBase = toCamelCase(path.basename(file, ".ts"));
    const count = usedNames.get(importBase) ?? 0;
    usedNames.set(importBase, count + 1);
    const importName = count === 0 ? importBase : `${importBase}${count + 1}`;

    const chapter = relPath.split("/")[0];
    scenes.push({ id, importName, relPath, chapter });
  }

  return scenes;
}

async function readInitialSceneId(outFile) {
  try {
    const existing = await fs.readFile(outFile, "utf8");
    const match = existing.match(
      /initialSceneId:\s*SceneId\s*=\s*["']([^"']*)["']/
    );
    return match ? match[1] : null;
  } catch {
    return null;
  }
}

function groupByChapter(scenes) {
  const groups = new Map();
  for (const scene of scenes) {
    const list = groups.get(scene.chapter) ?? [];
    list.push(scene);
    groups.set(scene.chapter, list);
  }
  return groups;
}

function buildFile(scenes, initialSceneId) {
  const groups = groupByChapter(scenes);
  const chapters = Array.from(groups.keys()).sort((a, b) =>
    a.localeCompare(b)
  );

  const lines = [];
  lines.push("// This file is auto-generated by generate-scenes.js.");
  lines.push("// Do not edit manually.");
  lines.push("");
  lines.push('import type { SceneDefinition } from "../../types/scenes";');
  lines.push("");

  for (const chapter of chapters) {
    lines.push(`// ${chapterLabel(chapter)}`);
    for (const scene of groups.get(chapter)) {
      lines.push(`import ${scene.importName} from "./${scene.relPath}";`);
    }
    lines.push("");
  }

  if (scenes.length === 0) {
    lines.push("export type SceneId = string;");
  } else {
    lines.push("export type SceneId =");
    for (const scene of scenes) {
      lines.push(`  | \"${scene.id}\"`);
    }
    lines.push(";");
  }
  lines.push("");
  lines.push("export const scenes: SceneDefinition[] = [");
  for (const chapter of chapters) {
    lines.push(`  // ${chapterLabel(chapter)}`);
    for (const scene of groups.get(chapter)) {
      lines.push(`  ${scene.importName},`);
    }
  }
  lines.push("];");
  lines.push(
    `export const initialSceneId: SceneId = \"${initialSceneId}\";`
  );
  lines.push("");

  return lines.join("\n");
}

async function generate() {
  const gameDirs = await listGameDirs();
  if (gameDirs.length === 0) {
    throw new Error("No game directories found under src/data.");
  }

  for (const gameDir of gameDirs) {
    const scenes = await readSceneFiles(gameDir);
    const outFile = path.join(gameDir, SCENES_FILE_NAME);
    const existingInitial = await readInitialSceneId(outFile);
    const fallbackInitial = scenes[0]?.id ?? "";
    const initialSceneId =
      existingInitial && scenes.some((scene) => scene.id === existingInitial)
        ? existingInitial
        : fallbackInitial;

    const output = buildFile(scenes, initialSceneId);
    await fs.writeFile(outFile, output, "utf8");
  }
}

async function listDirs(root) {
  const dirs = [root];
  const entries = await fs.readdir(root, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.isDirectory()) {
      const fullPath = path.join(root, entry.name);
      dirs.push(...(await listDirs(fullPath)));
    }
  }
  return dirs;
}

async function watchTree(onChange) {
  const watchers = new Map();
  const attach = async () => {
    const dirs = await listDirs(DATA_DIR);
    for (const dir of dirs) {
      if (watchers.has(dir)) {
        continue;
      }
      const watcher = fs.watch(dir, (eventType, filename) => {
        if (isDebug()) {
          const relDir = path.relative(process.cwd(), dir);
          console.log(`fs.watch ${eventType}`, relDir, filename ?? "");
        }
        onChange();
      });
      watchers.set(dir, watcher);
    }
  };

  await attach();
  return async () => {
    for (const watcher of watchers.values()) {
      watcher.close();
    }
  };
}

async function watchWithPolling(onChange) {
  let timeout = null;
  let lastRun = 0;

  const loop = async () => {
    const now = Date.now();
    if (now - lastRun >= POLL_INTERVAL_MS) {
      lastRun = now;
      onChange();
    }
    timeout = setTimeout(loop, POLL_INTERVAL_MS);
  };

  await loop();
  return () => {
    if (timeout) {
      clearTimeout(timeout);
    }
  };
}

async function run() {
  await generate();

  if (!isWatch()) {
    return;
  }

  let timeout = null;
  const schedule = () => {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      generate().catch((error) => {
        console.error("Failed to generate scenes", error);
      });
    }, WATCH_DEBOUNCE_MS);
  };

  const closeWatcher = isPoll()
    ? await watchWithPolling(schedule)
    : await watchTree(schedule);

  const handleExit = () => {
    closeWatcher();
    process.exit(0);
  };

  process.on("SIGINT", handleExit);
  process.on("SIGTERM", handleExit);
}

run().catch((error) => {
  console.error("Failed to generate scenes", error);
  process.exit(1);
});
